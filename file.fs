(*

    Largest palindrome product
    Submit

    Problem 4
    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

    Find the largest palindrome made from the product of two 3-digit numbers.
*)

let rec palin (x:string):bool = 
    printfn "%A" x
    if x.Length = 1 then 
        true 
    elif x.Length = 2  && x.[0] = x.[x.Length - 1] then
        true 
    else 
        // Check first and last
        if x.[0] <> x.[x.Length - 1] then 
            false 
        else 
            palin x.[1..x.Length - 2] 
            

printfn "%A" (palin "3301033")


// Divisible by two 3 digit numbers
let divisible x = 
    let rec divisible_inner (x:int) (acc:int): bool = // 9999 91 
        if acc.ToString().Length  > 3 then 
            false 
        else 
            let remainder =  x % acc 
    
            if remainder = 0 && acc.ToString().Length = 3 then
                let otherDigit = x / acc

                if otherDigit.ToString().Length = 3 then

                    if otherDigit * acc = x then
                        printfn "%A" acc
                        printfn "Other digit is %A" otherDigit
                        true 
                    else 
                        divisible_inner x (acc + 1)
                else 
                    divisible_inner x (acc + 1) 
            else 
                divisible_inner x (acc + 1)
    
    divisible_inner x 100



let b = seq {998001..-1.. 1} |> Seq.filter(fun a -> palin (string a)) |> Seq.filter(fun a -> divisible a) |> Seq.take 1
printfn "Result%A" b
(*
Split second to run

913
Other digit is 993
seq [906609]
*)




(*
Largest prime factor
Problem 3
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*)
let isPrime i =
    let rec isPrime_inner x acc:bool = 
        if x = 1L then 
            true 
        elif acc = x then 
            true 
        else 
            if x % acc = 0L then 
                false 
            else 
                isPrime_inner x (acc + 1L)
    isPrime_inner i 2L


let largestPrimeFactor i = 
    let rec largestPrimeFactor_inner x acc =
        if x = 1L || x = acc then 
          acc 
        elif isPrime acc then 
            if x % acc = 0L then 
                largestPrimeFactor_inner (x/acc) (acc + 1L)
            else 
                largestPrimeFactor_inner (x) (acc + 1L)
        else 
            largestPrimeFactor_inner (x) (acc + 1L)
    largestPrimeFactor_inner i 1L
            
let result = largestPrimeFactor 600851475143L

printfn "%A" result
//6857 
// Took about 10 seconds to run





(*
Problem 1
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.
*)

let result = [1..999] |> List.filter(fun a -> a % 3 = 0 || a % 5 = 0) |> List.reduce (+) //(fun acc i -> acc + i)
printfn "%A" result
//233168



(*
Problem 2
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*)
let fib x = 
    let rec fib_tail (i:int) (a_acc:int) (b_acc:int) (sum:int): int = 
        match i with 
        | 0 -> sum//a_acc 
        | 1 -> fib_tail(i - 1) (b_acc) (a_acc) (sum)
        | _ -> fib_tail (i - 1) (b_acc) (b_acc + a_acc) (if b_acc % 2= 0 && b_acc < 4000000 then b_acc + sum else sum)
  
    fib_tail x 1 2 0   //  "fib_tail x 1 2" allows for the first term to start at 1 as defined in sequence in question. (1, 2, 3, 5, 8)
    
printfn "%A" (fib 35)
